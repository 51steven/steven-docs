Java基础
====================
# 一.数据类型
Java 中的数据类型有两种，基本数据类型和引用数据类型。
- 基本数据类型又称为内置类型，Java保留了基本数据类型，主要是为满足 Java 高效率执行的需求。
- 引用数据类型又称为扩展类型，它的创建是需要去 new 一个对象，该对象的内存分配在堆区，同时栈区会保存一个指向该对象的引用。

## 1、基本类型
| 数据类型    | 大小（bit） | 默认值   | 包装类型   |
| :--------- |:----------:| --------:|----------:|
| byte       | 8          | 0        | Byte      |
| short      | 16         | 0        | Short     | 
| int        | 32         | 0        | Integer   | 
| long       | 64         | 0L       | Long      |
| float      | 32         | 0.0f     | Float     |
| double     | 64         | 0.0d     | Double    |
| char       | 16         | '\u0000' | Character | 
| boolean    | \~         | false    | Boolean   |
| void       | \~         | \~       | Void      |

- 浮点型有 float 、double , 默认数据类型是double。
- boolean 的值为：true、false，JVM会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。boolean 类型的数据可以用1 bit 来存储，但没有明确规定其大小。
- void 表示“没有东西”，如在方法返回值中，表示没有返回值；Void 为 void 的包装类，是一个占位符类，本身不起作用，不能被实例化，多用于泛型中作占位符使用。

- 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用**自动装箱与拆箱**完成。
    ```java
    Integer a = 1;     // 装箱
    int b = a;         // 拆箱
    ```

## 2、引用类型
Java常见的引用类型（对象类型）：类、接口、数组枚举以及字符串等。

如果要判断两个对象是否相同，则需要使用equals()方法，但有一点需要注意：equals()方法的默认行为是比较引用。如果是你自己写的类，你应该为它重写equals()来比较对象的内容。大多数Java类库都实现了比较对象内容的equals()方法。

## 3、缓存池
Integer 中有个静态内部类 IntegerCache ，里面有个 cache[],也就是 Integer 常量池，常量池的大小为一个字节（-128~127）。

new Integer(123) 与 Integer.valueOf(123) 的区别在于：
- new Integer(123) 每次都会新建一个对象；
- Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。

``jdk 1.8`` 源码中
```java
public static Integer valueOf(int i) {
    // 判断是否在缓存池范围中，如果在则返回缓存池中的内容，否则就new Integer() 创建一个新的对象。
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}

```

``IntegerCache`` 源码，从中可以知 Integer 默认缓存池的大小范围是 -128~127。
```java
 private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer cache[];

        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
            if (integerCacheHighPropValue != null) {
                try {
                    int i = parseInt(integerCacheHighPropValue);
                    i = Math.max(i, 127);
                    // Maximum array size is Integer.MAX_VALUE
                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;

            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k < cache.length; k++)
                cache[k] = new Integer(j++);

            // range [-128, 127] must be interned (JLS7 5.1.7)
            assert IntegerCache.high >= 127;
        }

        private IntegerCache() {}
    }
```

测试代码
```java
    Integer a = new Integer(123);
    Integer b = new Integer(123);
    System.out.println(a == b);     // false
    Integer x = Integer.valueOf(123);
    Integer y = Integer.valueOf(123);
    System.out.println(x == y);     // true
    // 编译器会在自动装箱过程调用 valueOf() 方法
    Integer n = 123;
    Integer m = 123;
    System.out.println(m == n);     // true
```

# 二、运算

## 1、运算符
运算符按其功能来分，有算术运算符、赋值运算符、关系运算符、逻辑运算符、位运算符等。

## 2、类型转换
数据类型转换分为**隐式类型转换**和**显示类型转换**。  

```text
基本数据类型
低  ------------------------------------>  高

byte,short,char—> int —> long—> float —> double 
```

a、隐式类型转换：小范围的数据类型转为大范围的数据类型称为隐式类型转换或自动类型转换。

- 使用 += 或者 ++ 运算符可以执行隐式类型转换。
```java
short s1 = 1;
// s1 = s1 + 1;  // 1 是 int 类型，不能隐式地将 int 类型下转型为 short 类型

s1 += 1;	  
// 或
s1++;
// 隐式类型转换，相当于 s1 = (short) (s1 + 1);
```

b、显示类型转换：大范围的数据类型转为小范围的数据称为显示类型转换或强制类型转换。
- 显示类型转换可能导致溢出或精度丢失。 

```java
// float f = 1.1;      // 编译不通过，浮点型默认为 double 
float f1 = 1.1f;
float f2 = (float) 1.1;
int i = (int) f1;
System.out.println(i); // 1
```

- 对于 byte、short、char 三种类型而言，他们是相同级别的，因此，不能相互隐式转换，但是可以显示类型转换。char 型向高级类型转换时，会转换成对应的ASCII码值。

```java
short s = 99;
char c = (char) s;
System.out.println(c); // c

byte b = (byte) c;
System.out.println(b); // 99

int n = (int) c;
System.out.println(n); // 99
```

除上述外类型转换还需注意：
    
-  在把大范围的类型转换为小范围的类型时必须使用显示类型转换；
- 引用数据类型的转换需存在继承关系；
- 不能对boolean类型进行类型转换。

# 三、字符串
> String 被声明为 final，因此它不可被继承，它们的值在创建之后不能修改。

## 1、String 源码片段

java.lang.String
```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {

/** String的属性值 */  
private final char value[];

/**数组被使用的开始位置**/
private final int offset;

/**String中元素的个数**/
private final int count;

/**String类型的hash值**/
private int hash; // Default to 0

......
```
从源码看出: 
- String 底层使用一个字符数组来维护（Java8）。Java9后使用 byte 数据，可参考 [Java9后String的空间优化](https://blog.csdn.net/wangyangzhizhou/article/details/80371653) 。
- value 数组被 final 修饰，意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，从而保证 String 不可变。

## 2、创建字符串对象两种方式

- 直接赋值

```java

```



String 不可变的好处：
-  



















# 参考：
- [Primitive Data Types](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
- [Integer缓冲池IntegerCache](https://blog.csdn.net/so_geili/article/details/79720238)

