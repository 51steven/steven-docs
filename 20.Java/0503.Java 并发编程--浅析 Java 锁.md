Java 并发编程--浅析 Java 锁
====================
锁作为并发共享数据，保证一致性的工具，在 JAVA 平台有多种实现(如：synchronized 等 ) 。这些现成的锁为我们开发提供了便利，下文将对常见的锁进行解析。

# 1、Java 锁的种类
## 1.1 乐观锁
乐观锁是乐观思想，即认为读多写少。遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。

java 中的乐观锁基本都是通过 CAS 操作实现的。

## 1.2 悲观锁
悲观锁是悲观思想，即认为写多。遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。Synchronized、RetreenLock 就是悲观锁。

## 1.3 自旋锁
自旋锁原理：若持有锁的线程能在很短时间内释放锁资源，那么等待竞争锁的线程就不需要进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样可以避免线程切换带来的性能损耗。

线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。若持有锁的线程执行的时间超过自旋等待的最大时间仍没有释放锁，则等待锁资源的线程会停止自旋并进入阻塞状态。

### 自旋锁的优缺点
自旋锁对于**锁资源竞争不激烈**，且**占用锁时间非常短**的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作消耗（两次线程上下文切换的消耗）。

当锁资源竞争激烈，或者持有锁的线程需要长时间占用锁执行代码块，若使用自旋锁，则在获取锁前线程会一直都是占用cpu 做无用功，将导致其他需要 cpu 的线程无法使用 cpu，造成 cpu 资源浪费，这种情况应关闭自旋锁。

## 1.4 同步锁


## 1.5 可重入锁（递归锁）
可重入锁，也称为递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受
影响。ReentrantLock 和 synchronized 都是可重入锁。

## 1.6 公平锁与非公平锁
- 公平锁（Fair）：加锁前检查是否有排队等待的线程，优先排队等待的线程获得锁，先来先得；
- 非公平锁（Fair）：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。
  - 非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核环境中维护一个队列；
  - synchronized 是非公平锁，ReentrantLock#lock() 默认采用的是非公平锁。

## 1.7 读写锁 ReadWriteLock
为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制。多个读锁不互斥，读锁与写锁互斥，这是由 jvm 控制的，我们只要用好相应的锁。

- 读锁：若代码中是只读数据，可以很多人同时读，但不能同时写，则使用读锁；在没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。
- 写锁：若代码中是修改数据，只能有一个人写，且不能同时读取，则使用写锁。

Java 提供了如下工具类：java.util.concurrent.locks.ReadWriteLock（接口）、java.util.concurrent.locks.ReentrantReadWriteLock（实现类）。

## 1.8 独占锁和共享锁
Java 并发包中的加锁模式分为：独占锁和共享锁。

### 独占锁
独占锁每次只能有一个线程能持有锁，如：ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。

### 共享锁
共享锁则允许多个线程同时获取锁，并发访问共享资源，如：ReadWriteLock。共享锁是一种乐观的加锁策略，允许多个执行读操作的线程同时访问共享资源。

- AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。
- ReadWriteLock，允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。

## 1.9 Java 锁的状态
Java 锁有 4 状态：无锁状态、偏向锁、轻量级锁和重量级锁。

### 重量级锁
Synchronized 是通过对象内部的监视器锁（monitor）来实现的。而监视器锁本质是依赖于操作系统的 Mutex Lock 来实现的。这种依赖于操作系统 Mutex Lock 实现的锁称为“重量级锁”。

操作系统实现线程之间的切换需要从用户态转换到核心态，成本非常高，状态之间的转换需要相对比较长的时间，这就是之前 Synchronized 效率低的原因。JDK 中对 Synchronized 做的种种优化，其原理就是为了减少重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。

一般而言，synchronized 使用的锁对象是存储在 Java 对象头里的，其主要结构是由 Mark Word 和 Class Metadata Address 组成。

### 轻量级锁
轻量级锁是 Java6 之后加入的新锁，它是一种针对加锁操作的优化手段，可在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。

轻量级锁所适应的场景：线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。

### 偏向锁
偏向锁是 Java6 之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。

偏向锁的核心思想：如果一个线程获得了锁，那么锁就进入偏向模式，此时 Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。

对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。

### 锁升级
随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁（锁的升级是单向的：只能从低到高升级，不会出现锁的降级）。

## 1.10 Java 锁的优化

### 分段锁
分段锁不是一种实际锁，而是一种优化思想。ConcurrentHashMap 是分段锁的一个完美实现。

### 减少持有锁的时间
只在有线程安全需求的程序上加锁。

### 减小锁的粒度
将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。
降低了锁的竞争，偏向锁、轻量级锁成功率才会提高。ConcurrentHashMap 是典型的减小锁粒度的案例。

### 锁分离
最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互
斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能。

读写分离思想可以延伸，只要操作互不影响，锁就可以分离。如：LinkedBlockingQueue 从头部取出，从尾部放数据。

### 锁粗化
一般的，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完
公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步
和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。

### 锁消除
消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java 虚拟机在 JIT 编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如：StringBuffer#append() 是一个同步方法，但是在 add() 中的 StringBuffer 属于一个局部变量，并且不会被其他线程所使用，因此 StringBuffer 不可能存在共享资源竞争的情景，JVM 会自动将其锁消除。

# 2、CAS 的实现原理
CAS（Compare And Swap，比较和交换），是设计并发算法时用到的一种技术。

比较交换过程：它包含 3 个参数 CAS(V, E, N)。V 表要更新的变量值(内存值)，E 表预期值(原始值)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。

CAS 操作是抱着乐观的态度进行的（乐观锁），它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并允许再次尝试，当然也允许失败的线程放弃操作。

## 2.1 实现原理
JAVA 中的 CAS 操作都是通过 sun.misc.Unsafe#compareAndSwapInt() 实现的，而 Unsafe#compareAndSwapInt() 利用 JNI 来完成 CPU 指令的操作。

C++ 源码分析参考：[java并发编程中的CAS机制，你理解嘛？](https://zhuanlan.zhihu.com/p/87136248)

## 2.2 CAS 存在的一些问题
cas 是一种非阻塞、轻量级的乐观锁，在资源竞争不激烈的情况下性能比重量级锁更高。但 cas 仍存在三个问题：
- 循环时间长开销很大。
- 只能保证一个变量的原子操作。
- ABA 问题。

### 循环时间长开销很大
CAS 通常是配合无限循环一起使用的，如果 CAS 失败，会一直进行尝试，当 CAS 长时间不成功，可能会给 CPU 带来很大的开销。

### 只能保证一个变量的原子操作
当对一个变量执行操作时，可以使用循环 CAS 的方式来保证原子操作，但是对多个变量操作时，CAS 目前无法直接保证操作的原子性。但是我们可以通过以下两种办法来解决：
- 使用互斥锁来保证原子性；
- 将多个变量封装成对象，通过 AtomicReference 来保证原子性。

### ABA 问题
CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提是需要取出内存中某时刻的数据，而在下一时刻比较并替换，那么在这个时间差类会导致数据的变化。

如：并发环境中，线程1 从内存位置 V 中取出 A，这时候线程2 也从内存中取出 A，并且
线程2 进行了一些操作变成了 B，然后 线程2 又将 V 位置的数据变成 A，这时线程1 进行CAS 操作发现内存中仍然是 A，然后线程1操作成功。尽管线程1 的 CAS 操作成功，但是不代表这个过程就是没有问题的（数据实际上已经被修改过，但 CAS 的机制无法察觉）。

Java 并发包提供了一个带有标记的原子引用类“AtomicStampedReference” 来解决“ABA 问题”，它可以通过控制变量值的版本来保证 CAS 的正确性。因此，在使用 CAS 前要考虑清楚“ABA 问题”是否会影响程序并发的正确性，如果需要解决“ABA 问题”，改用传统的互斥同步可能会比原子类更高效。

# 3、原子操作类
java.util.concurrent.atomic 包中提供了一组原子类。其基本的特性是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入（逻辑上的理解）。

java.util.concurrent.atomic 包中的原子类可细分为一下几种：
- 基本类型原子类
  - AtomicBoolean：布尔类型原子类
  - AtomicInteger：整型原子类
  - AtomicLong：长整型原子类
- 数组类型原子类
  - AtomicIntegerArray：整型数组原子类
  - AtomicLongArray：长整型数组原子类
  - AtomicReferenceArray：引用类型数组原子类
- 引用类型原子类：
  - AtomicReference：对象引用原子类
  - AtomicStampedReference：带有版本号的对象引用原子类
  - AtomicMarkableReference：带有标记位的对象引用原子类
- 原子属性更新类
  - AtomicIntegerFieldUpdater：原子更新volatile修饰的整型的字段的更新器
  - AtomicLongFieldUpdater：原子更新volatile修饰的长整型字段的更新器
  - AtomicReferenceFieldUpdater：原子更新volatile修饰的引用类型里的字段的更新器。

通过阅读原子类源码可以发现，sun.misc.Unsafe 类中提供了如下 3 个 CAS 操作方法：
```java
public final native boolean compareAndSwapInt(Object value, long valueOffset, int expect, int update);

public final native boolean compareAndSwapLong(Object value, long valueOffset, long expect, long update);

public final native boolean compareAndSwapObject(Object value, long valueOffset, Object expect, Object update);
```
其中
- value：需要操作的对象
- valueOffset：对象(value)的地址的偏移量（通过Unsafe.objectFieldOffset(Field valueField)获取）
- expect：更新时value的期待值
- update：将要更新的值

## 3.1 基本类型原子类 AtomicInteger
AtomicInteger 常用 API：
- int get()：AtomicInteger 对象返回基本类型值为 int 型。
- void lazySet(int newValue)：最终会设置成 newValue，使用 lazySet 设置值后，可导致其他线程在之后的一小段时间内还是可以读到旧的值。
- boolean compareAndSet(int expect，int update)：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。
- int addAndGet(int delta)：以原子方式将输入的数值与实例中的值（AtomicInteger 里的 value）相加，并返回结果。
- int getAndSet(int newValue)：以原子方式设置为 newValue 的值，并返回旧值。
- int getAndIncrement()：先返回后自增。
- int incrementAndGet()：先自增后返回。

示例代码：[AtomicIntegerDemo.java](https://github.com/IamDingj/corejava/blob/master/corejava-juc/src/main/java/com/dj/corejava/juc/lock/AtomicIntegerDemo.java)

## 3.2 引用类型原子类 

### AtomicStampedReference 源码解析
AtomicStampedReference 源码节选
```java
public class AtomicStampedReference<V> {

    // 封装需要更新的对象
    private static class Pair<T> {
        final T reference; // 维护对象引用
        final int stamp;   // int型的标志版本号
        private Pair(T reference, int stamp) {
            this.reference = reference;
            this.stamp = stamp;
        }
        static <T> Pair<T> of(T reference, int stamp) {
            return new Pair<T>(reference, stamp);
        }
    }
    // 保证 pair 在多线程中的可见性 
    private volatile Pair<V> pair;

    /**
      * expectedReference ：更新之前的原始引用
      * newReference : 将要更新的引用
      * expectedStamp : 更新之前的原始标志版本号
      * newStamp : 将要更新的标志版本号
      */
    public boolean compareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp) {
        Pair<V> current = pair; //当前pair
        return
            expectedReference == current.reference &&  //原始引用等于当前pair的引用，说明值未变化
            expectedStamp == current.stamp &&  //原始标志版本号等于当前pair标记版本号，说明标记未变化
            ((newReference == current.reference && newStamp == current.stamp) //将要更新的引用和标志版本号都等于当前值，说明将要更新的值都没有变化
            || casPair(current, Pair.of(newReference, newStamp))); //cas操作更新pair对象
    }
}
```
根据源码分析发现：AtomicStampedReference 通过维护包含1个对象引用和1个int型的标志版本号的pair对象，来解决ABA问题。在 zookeeper 中保持数据的一致性也是用的这种方式。

实现逻辑：在执行 compareAndSet（比较交换）时，会先判断当前值（“对象引用”和“标志版本号”，下同）和原始值是否分别相等，若不都相等说明值未变化，不用进行 CAS 操作；否则，判断当前值和将要更新值是否相等，若相等说明当前值就是将要更新的值，则当前值不需要更新；否则，将当前值和将要更新值进行 CAS 操作，一般的，新“标志版本号”在原“标志版本号”基础上递增。

示例代码：[AtomicStampedReferenceDemo.java](https://github.com/IamDingj/corejava/blob/master/corejava-juc/src/main/java/com/dj/corejava/juc/lock/AtomicStampedReferenceDemo.java)
### AtomicMarkableReference 源码解析
AtomicMarkableReference 实现逻辑和 AtomicStampedReference 类似，只是将一个 boolean 值作是否有更改的标记，就是说版本号只有两个：true 和false，修改的时候在这两个版本号之间来回切换，这样做并不能解决 ABA 的问题，只是降低了 ABA 问题发生的几率。

示例代码：[AtomicMarkableReferenceDemo.java](https://github.com/IamDingj/corejava/blob/master/corejava-juc/src/main/java/com/dj/corejava/juc/lock/AtomicMarkableReferenceDemo.java)

# 参考：
- [并发编程网](http://ifeve.com/java-concurrency-thread-directory/)
- [java并发编程中的CAS机制，你理解嘛？](https://zhuanlan.zhihu.com/p/87136248)
- [原子操作是如何实现的？](https://github.com/luohaha/MyBlog/issues/3)
- [深入浅出 Java Concurrency (2): 原子操作](http://www.blogjava.net/xylz/archive/2010/07/01/324988.html)
- [用AtomicStampedReference解决ABA问题](https://hesey.wang/2011/09/resolve-aba-by-atomicstampedreference.html)




