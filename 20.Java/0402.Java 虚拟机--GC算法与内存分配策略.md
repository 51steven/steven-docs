Java 虚拟机--GC 算法与内存分配策略
====================
# 一、判断一个对象是否存活
垃圾收集器在对堆进行回收前，首先要确定这些对象中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。

## 1.1 引用计数算法
**引用计数器判断对象是否存活的基本思路**：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。

引用计数算法的实现简单，判定效率高，大部分情况下是一个不错的算法。但它没有被主流的 JVM 采用，主要原因是它**很难解决对象之间循环引用的问题**。

## 1.2 可达性分析算法
**可达性分析算法判断对象是否存活的基本思路**：通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是 GC Roots 到这个对象不可达）时，则证明此对象时不可用的。
<div align="center"> <img src="images/040201.png" width="520px"> </div><br>

_上图中，对象object 5、object 6、object 7虽互有关联，但它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。_

在Java中，可作为GC Roots的对象包括以下几种：
- 虚拟机栈（栈帧中的局部变量表，Local Variable Table）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI（即一般说的Native方法）引用的对象。

## 1.3 引用类型
Java 将引用分为 强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)，这4种引用强度依次减弱。

- **强引用**，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。
- **软引用**，用来描述一些有用但非必须的对象。在系统将要发生内存溢出异常之前，会把这些对象列入回收范围之中进行对二次回收。
- **弱引用**，用来描述非必须对象，被弱引用关联的对象只能生成到下一次垃圾回收之前。
- **虚引用**，虚引用是否存在不会对对象的生存时间构成影响，也不能通过虚引用来获取对象实例，它唯一的作用是能在对象被收集器回收时收到一个系统通知。

# 二、垃圾收集算法
## 2.1 标记——清除算法 
标记－清除（Mark-Sweep）算法 ：分成“标记”、“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

标记——清除算法 是最基础的垃圾收集算法，后续的收集算法都是基于它的思路并对其不足进行改进而得到的。它主要的不足有两点：
- **效率问题**，标记和清除两个过程的效率都不高。
- **空间问题**，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不触发另一次垃圾收集动作。

## 2.2 复制算法
复制（Copying）算法 : 它将可用内存按容量**分成大小相等的两块**，每次只使用其中的一块。**当这一块内存用完，就将还存活着的对象复制到另一块上面**，然后再把已使用过的内存空间一次清理掉。

这样可以只对一块内存进行回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。虽然它解决标记-清除算法的效率问题，但使用内存缩小为原来的一半，代价有点高。

现在商用虚拟机都采用这种算法来回收新生代。

## 2.3 标记——整理算法 
标记－整理（Mark-Compact）算法 ：标记过程与“标记——清除算法”一样，但后续步骤不是直接对可回收对象进行清理，而是**让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存**。

复制算法在对象存活率较高时要进行较多的复制操作，效率将会变低。更关键的是：如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用复制算法，而用“标记——整理算法”。

## 2.4 分代收集算法 
分代收集（Generational Collection）算法 ：根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法。

- **新生代**：在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活。选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

- **老年代**：在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，所以使用“标记——清除”或“标记——整理”算法来进行回收。

当前商业虚拟机的垃圾收集都采用分代收集算法。

# 三、垃圾收集器
<div align="center"> <img src="images/040202.png" width="520px"> </div><br>
上图展示了 HotSpot 虚拟机中的 7 个垃圾收集器，若收集器之间存在连线则说明它们可以搭配使用。虚拟机所处区域，表示它是新生代收集器还是老年代收集器。

## 3.1 Serial 收集器
### 特性
Serial 收集器是一个单线程收集器。它只使用一个 CPU 或一条收集线程去完成收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有工作线程，直到收集结束。

### 运行示意图
<div align="center"> <img src="images/040203.png" width="520px"> </div><br>

### 使用场景
Serial 收集器的优点是简单、高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

它是 **Client 模式**下的默认**新生代**收集器。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。


## 3.2 ParNew 收集器
### 特性
ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为与 Serial 收集器完全一样。

### 运行示意图
<div align="center"> <img src="images/040204.png" width="520px"> </div><br>

### 使用场景
它是**Server 模式**下默认的**新生代**收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。

## 3.3  Parallel Scavenge 收集器
### 特性
 Parallel Scavenge 收集器和ParNew 收集器一样是一个新生代收集器，也是使用复制算法、并行的多线程收集器。

 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个**可控制的吞吐量**，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。

 吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)

### 使用场景
**停顿时间优先**，良好的响应速度能提升用户体验，适合需要与用户交互的程序。

**吞吐量优先**，可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。

## 3.4 Serial Old 收集器
### 特性
Serial Old 收集器是 Serial 收集器的**老年代**版本，是一个单线程收集器，使用“标记——整理”算法。

### 运行示意图
<div align="center"> <img src="images/040205.png" width="520px"> </div><br>

### 使用场景
适用于 **Client 模式**下的虚拟机使用。如果用在 Server 场景下，它有两个用途：

- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

## 3.5 Parallel Old 收集器
### 特性
Parallel Old 收集器是 Parallel Scavenge 收集器的**老年代**版本，使用多线程和“标记——整理”算法。

### 运行示意图
<div align="center"> <img src="images/040206.png" width="520px"> </div><br>

### 使用场景
在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

## 3.6 CMS 收集器
### 特性
CMS 收集器是一种以获取**最短回收停顿时间**为目标的收集器。它是基于“标记——清除”算法实现的，其运行过程分为**4个步骤**：

- 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
- 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
- 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
- 并发清除：不需要停顿。

具有以下缺点：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

### 运行示意图
<div align="center"> <img src="images/040207.png" width="520px"> </div><br>

### 使用场景
适用于重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验，常见于 Java应用的互联网站服务端。

## 3.7 G1 收集器
### 特性
G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。

具备如下特点：

- 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
- 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

### 运行示意图
<div align="center"> <img src="images/040208.png" width="520px"> </div><br>


# 四、内存分配与回收策略



# 参考：
- 《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明
