Java 虚拟机--Java内存区域
====================
# 一、运行时数据区域
<div align="center"> <img src="images/040101.jpg" width="520px"> </div><br>

## 1.1 程序计数器
是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。在虚拟机概念模型中，字节码解释器工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

## 1.2 Java 虚拟机栈
每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.5+ 默认为 1M
```java
java -Xss2M HackTheJava
```

该区域可能抛出以下异常：
- 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
- 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

## 1.3 本地方法栈
本地方法栈与 Java 虚拟机栈作用很相似，它们的区别在于虚拟机栈为虚拟机执行 Java 方法（即字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。

## 1.4 堆
对于大多数应用而言，Java堆（Heap）是 Java 虚拟机所管理的内存中最大的一块，它被所有线程共享的，在虚拟机启动时创建。此内存区域唯一的目的是存放对象实例，几乎所有的对象实例都在这里分配内存，且每次分配的空间是不定长的。

Java堆是垃圾收集器管理的主要区域，因此也被称为“GC堆（Garbage Collected Heap）”。从内存回收的角度看内存空间可如下划分：
- **新生代（Young）**： 新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低。在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。新生代又可细分为**Eden空间**、**From Survivor空间**、**To Survivor空间**，默认比例为8:1:1。
- **老年代（Tenured/Old）**：在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。

堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。

可以通过 -Xms(初始值) 和 -Xmx(最大值) 这两个虚拟机参数来指定一个程序的堆内存大小。
```test
java -Xms1M -Xmx2M HackTheJava
```

## 1.5 方法区
方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。Object Class Data(类定义数据)是存储在方法区的，此外，常量、静态变量、JIT编译后的代码也存储在方法区。

对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。

HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。

方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。

## 1.6 运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。

## 1.7 直接内存
直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分内存也被频繁运用，而却可能导致OutOfMemoryError异常出现，所以这里放到一起讲解。

以NIO（New Input/Output）类为例，NIO引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能避免在Java堆和Native堆中来回复制数据，在一些场景里显著提高性能。

# 二、HotSpot 中的对象

## 2.1 对象的创建
Java的对象创建的四种方式：
- **new关键字** : 我们最常见和最常用最简单的创建对象的方式。

- **使用 newInstance() 方法** : 这里包括 Class 类的newInstance() 方法和 Constructor 类的 newInstance() 方法。
- **使用 clone() 方法** ： 要使用 clone() 方法我们必须实现实现 Cloneable 接口，用 clone() 方法创建对象并不会调用任何构造函数。（浅拷贝）
- **反序列化** : 要实现反序列化我们需要让我们的类实现Serializable接口。当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。(深拷贝)

虚拟机遇到一条 new 指令时会做如下5个动作：

**1.类加载检查**  
虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，在检查这个符号引用代表的类是否已被加载、解析和初始化过的，如果没有，则先执行相应的类加载过程。

**2.分配内存**  
在类加载检查通过后，虚拟机就将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间同于从Java堆中划出一块大小确定的内存空间。**分配内存的方式**有两种：

- **指针碰撞（Bump The Pointer）** ：当 Java 堆中**内存绝对规整**时，所有用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。 

- **空闲列表（Free List）** ：当Java 堆中的**内存不规整**时， 已被使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

_选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。_


**并发情况下，分配内存线程安全问题的解决方案**：

- 对分配内存空间的动作进行同步，实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性。

- 把内存分配的动作按照线程划分在不同的空间之中进行 即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB ，Thread Local Allocation Buffer），哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，分配新的TLAB时才需要同步锁定。

**3.初始化**
内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。保证了实例字段在 Java 代码中可以不赋初始值而直接使用。

**4.对对象进行必要的设置**
虚拟机要设置对象的信息（如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息）并存放在对象的对象头（Object Header）中。

**5.执行 \<init> 方法**
在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在Java程序的视角看来，对象创建才刚刚开始——\<init>方法还没有执行，所有的字段都还为零值。所以一般来说（由字节码中是否跟随有 invokespecial 指令所决定），new 指令之后会接着执行\<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

## 2.2 对象的内存布局

## 2.3 对象的访问定位

# 参考：
- [JDK 8 api](https://docs.oracle.com/javase/8/docs/api/)
- [Java 集合系列18之 Iterator和Enumeration比较](https://www.cnblogs.com/skywang12345/p/3311275.html)
