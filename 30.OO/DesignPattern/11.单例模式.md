单例模式（`Singleton Pattern`）
====================
### **意图**
> 确保一个类只有一个实例，并提供一个全局访问点，又称为单件模式。

单例模式的三个要点：1.单例类只有一个实例对象；2.该单例对象必须由单例类自行创建；3.单例类对外提供一个访问该单例的全局访问点。

### **动机**
对于系统中的某些类来说，只能有一个对象，例如：线程池、缓存、注册表的对象等。若制造出多个实例，就会导致许多问题的产生，如：程序行为异常、资源使用过度、结果不一致等。  
如何保证一个对象只能被实例化一次？  
利用静态变量、静态方法和适当的访问修饰符，可以实现。而更好的方法是让单例类自身负责管理它的唯一实例。

### **适用性**
在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框等常常被设计成单例。

### **结构**
<div align="center"> <img src="images/11.singleton.png" width="280px"> </div><br>

### **实现**

- 饿汉式单例  
```java
public class Singleton {
    // 私有的静态属性
    private static Singleton instance = new Singleton();

    // 私有的构造方法
    private Singleton() {
    }

    // 公共的静态方法
    public static Singleton getInstance() {
        return instance;
    }

}
```
类一旦加载就创建一个实例，保证在调用 getInstance 方法之前实例已经存在了。线程不安全问题主要是由于 instance 被实例化多次，采取直接实例化 instance 的方式就不会产生线程不安全问题。但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。

- 懒汉式单例（非线程安全）  
```java
public class Singleton {
    //私有静态变量 instance 被延迟实例化
    private static Singleton instance = null;

    private Singleton() {}

    public static Singleton getInstance() {
        // 如果多个线程能够同时进入，将导致实例化多次 instance
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }

}
```
私有静态变量 instance 被延迟实例化，他好处是，如果没有用到该类，那么就不会实例化，从而节约资源。但是这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 if (instance == null) ，并且此时 instance 为 null，那么会有多个线程执行 instance = new Singleton();

- 双重校验锁机制（线程安全）  
```java
public class Singleton {
    // volatile 可禁止 JVM 的指令重排
    private static volatile Singleton instance = null;

    private Singleton() {}

    public static Singleton getUniqueInstance() {
        // 第一次检查，用来避免 instance 已经被实例化之后的加锁操作
        if (instance != null) {
            // 不创建
        } else {
            synchronized (Singleton.class) {
            // 第二次检查，加锁，确保只有一个线程进行实例化操作
            if (instance == null) {
                instance = new Singleton();
                }
            }
        }	
        return instance;
    }

}

```
这里在声明变量时使用了volatile关键字来保证其线程间的可见性； 在同步代码块中使用二次检查，以保证其不被重复实例化.集合其二者，这种实现方式既保证了其高效性，也保证了其线程安全性。
		 

### **已知应用**

### **相关模式**

# 参考资料
- 《`Head First` 设计模式》
- [图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)
- [Java设计模式：23种设计模式全面解析（超级详细）](http://c.biancheng.net/design_pattern/)
