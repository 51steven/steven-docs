分布式缓存
====================
# 1 缓存的概念

在计算机领域，**缓存技术**一般指，用一个更快的存储设备存储一些经常用到的数据，供用户快速访问。用户不需要每次都与慢设备去做交互，因此可以提高访问效率。

分布式缓存是指，在分布式环境或系统下，把一些热门数据存储到离用户近、离应用近的位置，并尽量存储到更快的设备，以减少远程数据传输的延迟，提高访问效率。

## 什么样的数据适合缓存

可以从访问频率、读写比例及数据一致性等角度去分析一个数据是否适合缓存：

- **数据访问频率**：数据访问频率高，适合缓存；访问频率低，不建议；
- **数据读写比例**：读多写少，适合缓存；其他不建议；
- **数据一致性**：一致性要求低，适合缓存；一致性要求高，不建议；


# 2 SpringCache 的用法

Spring Cache是 Spring框架提供的对缓存使用的抽象类，支持多种缓存，比如 Redis、EHCache 等，集成很方便。同时提供了多种注解来简化缓存的使用，可对方法进行缓存。

## 2.1 缓存注解

SpringCache 缓存功能的实现是依靠下面的这几个注解完成：

- @EnableCaching：开启缓存功能
- @Cacheable：缓存查询
- @CachePut：缓存增改
- @CacheEvict：缓存删除
- @Caching：组合多个注解
- @CacheConfig：抽取公共配置（类级别）

具体参考：[优雅的缓存解决方案--SpringCache和Redis集成(SpringBoot)](https://juejin.im/post/6844903807646711821)

### @Cacheable

<img src=".\images\0201.png" alt="0201" style="zoom: 67%;" />

### @CachePut

<img src=".\images\0202.png" alt="0202" style="zoom: 67%;" />

### @CachEvict

<img src=".\images\0203.png" alt="0203" style="zoom: 67%;" />

## 2.2 SpEL 表达式

SpEL 表达式可基于上下文并通过使用缓存抽象，提供与 root 独享相关联的缓存特定的内置参数。

<img src=".\images\0204.png" alt="0204" style="zoom: 80%;" />

## 2.3 Key 的配置

Key的手动设置，例如：key = "#root.targetClass.simpleName+':'+#root.methodName+':'+#param"

# 3 缓存雪崩

## 3.1 什么是缓存雪崩

> 缓存集中在一段时间内失效，导致所有的查询都落在数据库上，称之缓存雪崩。

高并发的数据查询，将对数据库服务器的 CPU 和内存造成巨大压力，严重情况可能造成数据库服务器宕机。

## 3.2 缓存雪崩策略

### 1).加锁排队

采用 mutex 互斥锁来解决。Redis 的 SETNX 去 set 一个 mutex key，当操作返回成功时，再进行加载数据库的操作并回设缓存，否则，就重试 get 缓存。

### 2).数据预热

缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。可以通过缓存 reload 机制，预先更新缓存，再即将发生大并发访问前手动触发加载缓存不同的 key。

### 3).双层缓存策略

C1 为原始缓存，C2 为拷贝缓存，C1 失效时，可以访问 C2，C1 缓存失效时间设置为短期，C2 设置为长期。

### 4).定时更新缓存策略

实效性要求不高的缓存，容器启动初始化加载，采用定时任务更新或移除缓存。

### 5).设置不同的过期时间，让缓存失效的时间点尽量均匀

# 4 缓存穿透

## 4.1 什么是缓存穿透

> 查询数据库中不存在的数据，导致所有的请求都打到数据库上。

## 4.2 缓存穿透策略

### 1).缓存空值

如果一个查询返回的数据为空（不管是数据不存在，还是系统故障）我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过5分钟。通过这个设置的默认值存放到缓存，这样第二次查询缓存中获取就有值了，而不会继续访问数据库。

### 2).布隆过滤器 BloomFilter

占用内存空间很小，位存储；性能特别高，使用 key 的 hash 判断 key 存不存在。

将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

在缓存之前在加一层 BloomFilter，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再去查询缓存，缓存中没有再去查询数据库。

# 参考
- [深入理解分布式缓存设计](https://zhuanlan.zhihu.com/p/55303228)

- [布隆过滤器(Bloom Filter)详解](https://www.cnblogs.com/liyulong1982/p/6013002.html)
- [优雅的缓存解决方案--SpringCache和Redis集成(SpringBoot)](https://juejin.im/post/6844903807646711821)
- [缓存更新的套路](https://coolshell.cn/articles/17416.html)