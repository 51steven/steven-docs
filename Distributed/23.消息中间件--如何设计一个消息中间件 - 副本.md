消息中间件--概述
====================

## 1 消息中间件相关概念

说到消息中间件，我们会联想到一些消息中间件相关的概念，如：中间件、消息、消息队列、消息代理和消息中间件，具体介绍如下文。

### 1.1 中间件

中间件(`Middleware`) 是帮助应用程序与其他应用程序、网络、硬件、操作系统进行**交互或通信**的软件。中间件相对于架构体系而言，它不涉及具体的业务逻辑和底层的硬件逻辑，用于用户数据交换和管理，能够起到**中介**的作用。

一般地，中间件是为了解决**某特定领域**的**某类问题**而产生的组件，例如：

- **数据库中间件**

  随着业务的发展，数据库（如 MySQL、Oracle）中数据量越来越大，可能会导致查询、新增、修改数据变慢，我们可以使用分库分表、读写分离等方案来解决，于是需要引入数据库中间件用于管理分布式数据库。

  一般地，数据库中间件可以提供功能如：QPS 和数据分片的限制、读写分离、路由策略、统计、管理、鉴权等。而这些功能都在业务逻辑之外，应该抽象出一个独立的组件，也就是数据库中间件。

  目前主流的数据库中间件如：

  - `MyCAT`：社区爱好者在阿里 `cobar` 基础上进行二次开发，解决了 `cobar` 存在的一些问题，并且加入了许多新的功能在其中。`MyCAT` 社区活跃度很高，目前已经有一些公司在使用 `MyCAT`。
  - `OneProxy`：数据库界大牛，前支付宝数据库团队领导楼总开发，基于 MySQL 官方的 proxy 思想，使用 c 语言进行开发的。`OneProxy` 是一款商业收费的中间件，楼总舍去了一些功能点，专注在性能和稳定性上。
  - `ShardingSphere`：源于当当网的 `ShardingJDBC` 框架。Apache 基金会的数据库中间件，社区活跃高，后起之秀。

- **Web 中间件**

  Web 服务器上负责解析 HTTP 请求的一组应用程序。具体职责是**接收并解析 HTTP 请求数据包，在服务器上找到数据包所请求的文件后，将其返回给客户端**；若 HTTP 数据包所请求的是一个动态脚本文件（如 `.php` 文件），Web 中间件会根据 CGI 与脚本语言解析软件进行交互，处理完动态脚本文件后，再将处理后的文件返回给浏览器。

  常见的 Web 中间件如：`Tomcat，WebLogic，Jboss，Jetty，WebShere`。  

- **消息中间件**

  消息中间件是使用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统集成的组件。

  常见的消息中间件如：`ActiveMQ，RabbitMQ，ZeroMQ，Kafka，RocketMQ`。

### 1.2 消息队列

消息队列(`Message Queue`，简称 MQ)可以理解为：**消息(Message ) + 队列(Queue)**。

- 消息：数据的载体，一个数据传输单位，包含了创建时间、通道/主题信息、输入参数等全部数据；
- 队列：一种先进先出(`FIFO`)的数据结构，编程语言内置（内存中的）队列的实现，可用作进程间通讯（`IPC`）的方法。使用队列最常用的场景是**生产者/消费者模式**。

常见的消息队列有：`ActiveMQ，RabbitMQ，ZeroMQ，Kafka，RocketMQ`。

**消息中间件和消息队列的区别与联系**

一般地，MQ 是指实现了生产者/消费者模式的中间件。MQ 偏向数据结构、业务场景层面的概念，而消息中间件偏向于系统架构；MQ 偏向于微观的概念，消息中间件偏向于宏观。

### 1.3 消息代理

消息代理(`Message Broker`)是一种架构模式，用于消息验证、变换、路由。虽然不同的消息中间件的架构和实现不同，但大部分实现了 Broker。

Broker 是消息中间件的服务器，是中间件的核心。例如：Kafka 中，一台 Kafka 服务器就是一个 broker，一个集群由多个 broker 组成。

*注：`RabbitMQ、Kafka、RocketMQ` 等都有消息代理，但不是所有中间件都有，如 `ZeroMQ`用的是套接字风格的API。*

### 1.4 消息中间件

消息中间件是分布式系统中重要的组件，主要解决异步消息，应用解耦，流量削锋等问题，实现了高性能，高可用，可伸缩和最终一致性的架构。常见的消息中间件如：`ActiveMQ，RabbitMQ，ZeroMQ，Kafka，RocketMQ，MetaMQ`。

因为消息中间件和消息队列的概念近似，且我们用到的消息中间件基本上是消息队列，所以后文将统一使用消息队列（MQ）进行描述。

## 2 消息队列的应用场景

介绍消息中间件相关概念后，接着介绍消息队列在实际应用中几个常用的场景。

### 2.1 异步处理

场景描述：用户注册后，需要发注册邮件和注册短信。

传统的方式有两种：

- 串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上 3 个任务全部完成后，返回给客户端。如下图：

  <img src=".\images\2101.png" style="zoom: 67%;" />

- 并行方式：将注册信息写入数据库成功后，同时发送注册邮件、注册短信。以上 3 个任务完成后，返回给客户端。如下图：

  <img src=".\images\2102.png" style="zoom: 67%;" />

如传统方式下，系统的性能(并发量，吞吐量，响应时间)存在瓶颈。我们可以引入消息队列，将非必须的业务逻辑进行异步处理，以提高系统性能。如下图：

<img src=".\images\2103.png" style="zoom: 67%;" />

### 2.2 应用解耦

场景描述：用户下单后，订单系统需要通知库存系统。

传统的方式是，订单系统调用库存系统的接口。如下图：

<img src=".\images\2104.png" style="zoom: 67%;" />

传统方式下，若库存系统无法访问，则订单减库存失败，从而导致订单失败，系统间的耦合度较高。我们可以引入消息队列，实现订单系统与库存系统的应用解耦。如下图：

<img src=".\images\2105.png" style="zoom: 67%;" />

### 2.3 流量削锋

场景描述：在秒杀或团抢活动中，可能会由于流量过大、流量暴增，导致服务宕机。我们可以在应用前端加入消息队列从而实现流量削锋。

<img src=".\images\2106.png" style="zoom: 67%;" />

系统接收用户请求后，先写入消息队列；若消息队列中存储数据超过阈值，则直接抛弃用户请求或跳转到错误页面；秒杀业务根据消息队列中的请求信息，再做后续处理。

### 2.4 日志处理

可以使用消息队列（如 Kafka）处理日志，解决大量日志传输的问题。

<img src=".\images\2107.png" style="zoom: 67%;" />

### 2.5 消息通信

消息队列依据**消息传递机制**在协作进程间交换消息来实现通信。消息传递（消息队列）作为**进程间通信（IPC）**的一种方式，具备如下特点：

- 消息队列可以随机读取消息，消息不一定要以先进先出的次序读取，也可以按消息的类型读取；
- 消息队列允许一个或多个进程向它写入或读取消息；
- 从消息队列中读出消息，消息队列中对应的数据都会被删除；
-  每个消息队列都有一个唯一的标识符。

消息传递有两种类型：

- **点对点模式**（`point-to-point`），用于**生产者（Producer）**和**消费者（Consumer）**之间点到点的通信。即一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。

  <img src=".\images\2108.png" style="zoom: 67%;" />

- **发布/ 订阅模式**（`publish/subscribe`），即多个**发布者（Publisher）**将消息发送到**主题（Topic）**，系统将这些消息传递给多个**订阅者（Subscriber）**。

  <img src=".\images\2109.png" style="zoom: 67%;" />

## 3 常见的消息队列

在了解消息队列是什么，用来干什么后。再简单介绍几个常见的消息队列，并根据各消息队列产品进行比较。

### 3.1 各消息队列简介

常见的消息队列如：`ActiveMQ，RabbitMQ，ZeroMQ，Kafka，RocketMQ`。

#### 3.1.1 `ActiveMQ`

`Apache ActiveMQ` 是最受欢迎且功能最强大的开源消息传递和 Integration Patterns 服务器。`ActiveMQ` 速度快，支持许多跨语言客户端和协议，易于集成 Spring 框架，同时完全支持 JMS 1.1和 J2EE 1.4；`ActiveMQ` 是在 Apache 2.0 许可下发布。

- **优点**
  - 单机吞吐量：万级
  - 时效性：ms 级
  - 可用性：高，基于主从架构实现高可用
  - 消息可靠性：有较低的概率丢失数据
  - 功能支持：MQ 领域的功能极其完备

- **缺点**
  - 官方社区现在对 `ActiveMQ 5.x` 维护越来越少，较少在大规模吞吐的场景中使用。

#### 3.1.2 `RabbitMQ`

`RabbitMQ` 是使用 Erlang 语言开发的开源消息队列系统，基于 AMQP 协议实现。AMQP 的主要特征是面向消息、队列、路由(包括点对点和发布/订阅)、可靠性、安全。AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。

- **优点**

  - 由于 Erlang 语言的特性，MQ 性能较好，高并发；
  - 吞吐量到万级，MQ 功能比较完备； 

  - 健壮、稳定、易用、跨平台、支持多种语言、文档齐全；

  - 开源社区提供的管理界面很好用；

  - 社区活跃度高。

- **缺点**

  - Erlang 开发，源码很难看懂，不利于二次开发和维护，对社区依赖较高；
  - 基于 AMQP 协议实现，比较重，吞吐量较低；
  - 学习成本较高。

#### 3.1.3 `ZeroMQ`

号称最快的消息队列系统，尤其针对大吞吐量的需求场景。`ZeroMQ` 是一个网络编程的 Pattern 库，将常见的网络请求形式(分组管理，链接管理，发布订阅等)模式化、组件化；`ZeroMQ` 介于 socket 和 MQ 之间。对于 MQ 来说，网络传输只是它的一部分，更多需要处理的是消息存储、路由、Broker 服务发现和查找、事务、消费模式(ack、重投等)、集群服务等。

#### 3.1.4 `Kafka`

Kafka 是由 Apache 开发的一个开源流处理平台，由 Scala 和 Java 语言实现。Kafka 是一种高吞吐量的分布式发布/订阅消息系统，主要用于处理活跃的流式数据，大数据量的数据处理，在数据采集、传输、存储的过程中发挥着举足轻重的作用。

**优点**

- 性能卓越，吞吐量高，单机写入 TPS 约在百万条/秒；
- 时效性：ms 级；
- 可用性：非常高，Kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用；
- 消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次；
- 有优秀的第三方管理界面（Kafka-Manager）；
- 在日志领域比较成熟，被多家公司和多个开源项目使用；
- 功能支持：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。

**缺点**

- Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，Load 越高，发送消息响应时间变长；
- 使用短轮询方式，实时性取决于轮询间隔时间；
- 消费失败不支持重试；
- 支持消息顺序，但是一台代理宕机后，会产生消息乱序；
- 社区更新较慢。

#### 3.1.5 `RocketMQ`

`RocketMQ` 是阿里开源的消息中间件，是纯 Java 语言实现，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。`RocketMQ` 思路起源于 Kafka，但并不是 Kafka 的一个 Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、`binglog` 分发等场景。

**优点**

- 单机吞吐量：十万级；
- 可用性：非常高，分布式架构；
- 消息可靠性：经过参数优化配置，消息可以做到 0 丢失；
- 功能支持：MQ 功能较为完善，扩展性好；
- 支持 10 亿级别的消息堆积，不会因为堆积导致性能下降；
-  Java 语言实现，易于维护和二次开发。

**缺点**

- 支持的客户端语言不多，目前是 Java 及 c++，其中 c++ 不成熟；
- 社区活跃度一般；
- 没有在 MQ 核心中去实现 JMS 等接口，有些系统要迁移需要修改大量代码。

### 3.2 消息队列产品比较

消息队列产品比较如下表：

| 特性       | `ActiveMQ`                                       | `RabbitMQ`                     | `Kafka`                                  | `RocketMQ`             |
| ---------- | ------------------------------------------------ | ------------------------------ | ---------------------------------------- | ---------------------- |
| 开发语言   | Java                                             | Erlang                         | Scala 和 Java                            | Java                   |
| 单机吞吐量 | 万级                                             | 万级                           | 10万级                                   | 10万级                 |
| 时效性     | ms级                                             | us级                           | ms级以内                                 | ms级                   |
| 可用性     | 高（主从架构）                                   | 高（主从架构）                 | 非常高（分布式架构）                     | 非常高（分布式架构）   |
| 功能       | 成熟的产品，应用广泛，有较多的文档，支持各种协议 | 并发性好，延时低，管理界面友好 | 只支持主要的MQ功能，在大数据领域应用广泛 | MQ功能较完备，扩展性好 |

### 3.3 消息队列选型

消息队列选择建议如下：

- `RabbitMQ`

  结合 Erlang 语言本身的并发优势，性能较好，产品非常成熟；虽然不利于做二次开发，但社区活跃度比较高，可以解决开发过程中遇到的 bug。如果数据量不大、小公司可选择功能比较完备的 RabbitMQ。

- `Kafka` 

  Kafka 主要特点是基于 Pull 模式来处理消息，追求高吞吐量，适合产生大量数据的数据收集业务；日志采集功能，首选 Kafka。

- `RocketMQ`

  为金融互联网领域而生，对于可靠性要求很高的场景，如：电商的订单扣款、业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。`RoketMQ` 经历了阿里双11的考验，稳定性值得信赖。

## 2 JMS 简介

`JMS（Java Messaging Service）`是Java平台上有关面向消息中间件的**技术规范**，它便于消息系统中的 Java 应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。

JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。

- `TextMessage`：一个字符串对象
- `MapMessage`：一套名称-值对
- `ObjectMessage`：一个序列化的 Java 对象
- `BytesMessage`：一个字节的数据流
- `StreamMessage`：Java 原始值的数据流

### JMS 消息传递类型

对于消息的传递有两种类型：

- **点对点传递**，即一个生产者和一个消费者一一对应；

  <img src=".\images\2101.png" style="zoom: 80%;" />

- **发布/ 订阅模式**，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。

  <img src=".\images\2102.png" style="zoom: 80%;" />

# 参考

- [消息队列、消息代理和消息中间件的区别和联系](https://developer.51cto.com/art/201907/599859.htm)
- [中间件、服务器和Web服务器三者的区别](https://www.cnblogs.com/greycdoer0/p/10484309.html)
- [理解进程间通信](https://zhuanlan.zhihu.com/p/123377340)