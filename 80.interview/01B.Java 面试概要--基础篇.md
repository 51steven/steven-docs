Java 面试概要--基础篇
===================================
# 1.Java 基础
## 1.1 面向对象的基本特征

封装：是包装、信息隐藏的意思。就一个对象而言它所封装的是自己的属性和方法，所以说封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。  
良好的封装可以降低耦合、提高程序的可复用性和可维护性。

继承：是从已有的类中派生出新的类，新的类能继承已有类的非私有属性和方法，并能扩展新的能力。  
java是单继承，但可以多重继承；继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的；继承是一种强耦合关系父类变，子类就必须变；在设计模式中我们提倡多用组合关系，少用继承关系，以降低程序的耦合度。

多态：是同一个行为具有多个不同表现形式。多态就是同一个接口，使用不同的实例而执行不同操作。

多态分为编译时多态和运行时多态：编译时多态是静态的，主要是指方法的重载;运行时多态是动态的，指程序中定义的对象引用所指向的具体类型在运行期间才确定，方法的重写。

## 1.2 重载和重写的区别

方法重载：是发生在一个类中多态性的一种表现（编译时多态）。
重载时，方法名相同，参数类型、个数不同，返回类型不做要求，访问修饰符不做要求，抛出异常不做要求。

方法重写：父类与子类之间的多态性，对父类的函数进行重新定义。  
若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。  
重写规则：
- 参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。 
- 返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。
- 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private）
- 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如： 父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。

## 1.3 抽象类和接口有什么区别
抽象类是用来捕捉子类的通用特性的 。它不能被实例化，只能被用作子类的超类。  
接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。  

java 8中抽象类与接口的异同：  
**相同点**：
- 都是抽象类型；
- 都可以有实现方法（以前接口不行）；
- 都可以不需要实现类或者继承者去实现所有方法，（以前不行，现在接口中默认方法不需要实现者实现）

**不同点**：
- 抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）；
- 抽象类和接口所反映出的设计理念不同。其实抽象类表示的是"is-a"关系，接口表示的是"like-a"关系；
- 接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。

_friendly 型：如果一个类、类属变量及方法不以public,protected,private这三种修饰符来修饰，它就是friendly类型的。这种类、类属变量及方法对包内的其他类是友好的，开放的，而对包外的其他类是关闭的。_

## 1.4 int 和 Integer 有什么区别
区别 ：
- Integer是int的包装类，int则是java的一种基本数据类型 
- Integer变量必须实例化后才能使用，而int变量不需要 
- Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 
- Integer的默认值是null，int的默认值是0
- int类型是java内置的基本数据类型，其数据都是在栈中操作，对变量的创建、销毁速度非常快；而Integer是引用类型，其数据是在堆中操作，对象的创建、销毁都比较慢。

## 1.5 final, finally, finalize 的区别
- final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承。
- finally 是异常处理语句结构的一部分，表示总是执行。
- finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用。

## 1.6 说说反射的用途及实现

### **用途**
反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先知道运行对象是谁。

在很多的项目比如 Spring，MyBatis 都都可以看到反射的身影。我们还可以利用反射机制实现工厂模式和代理模式等设计模式，也可以解决 Java 泛型擦除等令人苦恼的问题。

### **实现**
获取一个对象对应的反射类，在 Java 中可以通过如下方式获取一个对象的反射类：
- 通过 getClass() 方法
- 通过 Class.forName() 方法
- 使用 类.class
- 通过类加载器实现，getClassLoader()

### **注意**
 由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。

## 1.7 说说自定义注解的场景及实现
关于『注解』和『XML』两种不同的配置模式，各有各的优劣，注解可以提供更大的便捷性，易于维护修改，但耦合度高，而 XML 相对于注解则是相反的。

注解的本质: **所有的注解类型都继承自这个普通的接口（Annotation）**

一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有解析它的代码，它可能连注释都不如。而解析一个类或者方法的注解往往有两种形式，一种是编译期直接的扫描，一种是运行期反射。

## 元注解
java中的四种元注解：
- @Target：注解的作用目标
- @Retention：注解的生命周期
- @Documented：注解是否应当被包含在 JavaDoc 文档中
- @Inherited：是否允许子类继承该注解

## 自定义注解使用场景
- 类属性自动赋值。
- 验证对象属性完整性。
- 代替配置文件功能，像spring基于注解的配置。
- 可以生成文档，像java代码注释中的@see,@param等。

# 1.8 equals 与 == 的区别

# 1.9 JDBC 流程

# Java 容器
- List 和 Set 区别

- List 和 Map 区别
- Arraylist 与 LinkedList 区别
- ArrayList 与 Vector 区别
- HashMap 和 Hashtable 的区别
- HashSet 和 HashMap 区别
- HashMap 和 ConcurrentHashMap 的区别
- HashMap 的工作原理及代码实现
- ConcurrentHashMap 的工作原理及代码实现

# Java 虚拟机



# Java 并发
- 创建线程的方式及实现

- sleep() 、join（）、yield（）有什么区别
- 说说 CountDownLatch 原理
- 说说 CyclicBarrier 原理
- 说说 Semaphore 原理
- 说说 Exchanger 原理
- 说说 CountDownLatch 与 CyclicBarrier 区别
- ThreadLocal 原理分析
- 讲讲线程池的实现原理
- 线程池的几种方式
- 线程的生命周期
- 锁机制
- 说说线程安全问题
- volatile 实现原理
- synchronize 实现原理
- synchronized 与 lock 的区别
- CAS 乐观锁
- ABA 问题
- 乐观锁的业务场景及实现方式



# 参考
- [JAVA 注解的基本原理](https://www.cnblogs.com/yangming1996/p/9295168.html)
- [JAVA自定义注解、元注解介绍及自定义注解使用场景](https://blog.csdn.net/bluuusea/article/details/79996572)











