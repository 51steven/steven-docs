Redis 学习笔记--集群模式
====================
# 1 Redis 集群简介

Redis 集群（Redis Cluster）是 Redis 3.0 开始引入的分布式存储方案。

集群由多个节点(Node)组成，Redis 的数据分布在这些节点中。集群中的节点分为主节点和从节点：**主节点负责读写请求和集群信息的维护，从节点只进行主节点数据和状态信息的复制**。

相对于主从和哨兵模式，Redis 集群的优势主要体现在如下两方面：

- 数据分区（数据分片）：将数据分散到多个节点，一方面突破了 Redis 单机内存大小的限制，存储容量大大增加；另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。
- 高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。

## 架构图

Redis Cluster 架构图如下：

<img src=".\images\2501.png" alt="2501" style="zoom:80%;" />



# 2 Redis Cluster 搭建

集群的搭建方式有两种：

- 手动执行 Redis 命令，一步步完成搭建；
- 使用 Ruby 脚本搭建，原理和第一种相同。使用 Ruby 脚本将 Redis 命令进行了打包封装；在实际应用中推荐使用脚本方式，简单快捷不易出错。

## 2.1 Redis Cluster 规划

|      IP       | 端口号 |  角色  |
| :-----------: | :----: | :----: |
| 47.106.125.36 |  7001  | Master |
| 47.106.125.36 |  7002  | Master |
| 47.106.125.36 |  7003  | Master |
| 47.106.125.36 |  8001  | Slave  |
| 47.106.125.36 |  8002  | Slave  |
| 47.106.125.36 |  8003  | Slave  |

## 2.2 执行 Redis 命令搭建集群

集群的搭建可以分为四步：

- 启动节点：将节点以集群模式启动，此时节点是独立的，并没有建立联系；
- 节点握手：让独立的节点连成一个网络；
- 分配槽：将 16384 个槽分配给主节点；
- 指定主从关系：为从节点指定主节点。

### 1).启动节点

配置每个节点的 `redis.conf` 相关参数，使用 `./redis-server` 命令启动每个 redis 节点：

```tex
cluster-enabled yes
cluster-config-file "node01.conf"
```

- cluster-enabled yes：Redis 实例分为单机模式(standalone)和集群模式(cluster) ，cluster-enabled yes 表启用集群模式(cluster)。
- cluster-config-file：指定**集群配置文件**的位置。每个节点在运行过程中，会维护一份集群配置文件；当集群信息发生变化时（如增减节点），集群内所有节点会将最新信息更新到该配置文件；当节点重启后，会重新读取该配置文件，获取集群信息。

### 2).节点握手

通过节点握手，将独立的节点组成一个网络。

节点握手使用 `cluster meet {ip} {port}` 命令实现。例如：在 47.106.125.36:7001节点上执行 47.106.125.36:8001 ，可以完成 7001节点和 8001 节点的握手。

### 3).分配槽

槽是数据管理和迁移的基本单位，在 Redis 集群中，借助槽实现数据分区（后文详述）。

集群有 16384 个槽，当数据库中的 16384 个槽都分配了节点时，集群处于上线状态（ok）；如果有任意一个槽没有分配节点，则集群处于下线状态（fail）。

`cluster info` 命令可以查看集群状态，分配槽之前状态为 fail。

分配槽使用 `cluster addslots` 命令，在各**主节点**执行  cluster addslots 将槽（编号0-16383）全部分配完毕：

```tex
redis-cli -p 6379 cluster addslots {0..5461}
redis-cli -p 6379 cluster addslots {5462..10922}
redis-cli -p 6379 cluster addslots {10923..16383}
```

### 4).指定主从关系

集群中指定主从关系不再使用 slaveof 命令，而是使用 `cluster replicate` 命令，参数使用节点 id。

通过 `cluster nodes` 命令分别获取主节点id，执行下面的命令为每个从节点指定主节点：

```tex
redis-cli -p 6379 cluster replicate be816eba968bc16c884b963d768c945e86ac51ae
redis-cli -p 6379 cluster replicate 788b361563acb175ce8232569347812a12f1fdb4
redis-cli -p 6379 cluster replicate a26f1624a3da3e5197dde267de683d61bb2dcbf1
```

## 2.3 使用 Ruby 脚本搭建集群

### 1).安装 Ruby 环境

以 Ubuntu 为例，如下操作即可安装 Ruby 环境：

```tex
apt-get install ruby #安装ruby环境
gem install redis #gem是ruby的包管理工具，用于安装ruby-redis依赖
```

### 2).启动节点

与第一种方法相同。

### 3).搭建集群

redis-trib.rb 脚本提供了许多命令，其中 create 用于搭建集群，具体操作如下：

```tex
./redis-trib.rb create --replicas 1 47.106.125.36 6379 47.106.125.36 6380 47.106.125.37 6379 47.106.125.37 6380 47.106.125.386379 47.106.125.38 6380
```

--replicas=1表示每个主节点有1个从节点；后面的多个{ip:port}表示节点地址，前面是主节点，后面是从节点。使用 redis-trib.rb 搭建集群时，要求节点不能包含任何槽和数据。

# 3 集群的基本原理

## 3.1 数据分区方案

数据分区有顺序分区、哈希分区等，其中哈希分区由于其天然的随机性，使用广泛；集群的分区方案便是哈希分区的一种。

**哈希分区的基本思路**：对数据的特征值（如key）进行哈希，然后根据哈希值决定数据落在哪个节点。

常见的哈希分区包括：哈希取余分区、一致性哈希分区、带虚拟节点的一致性哈希分区等。

### 3.1.1 哈希取余分区

哈希取余分区思路：计算 key 的 hash 值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。

该方案最大的问题是，当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。

### 3.1.2 一致性哈希分区

一致性哈希算法将整个哈希值空间组织成一个虚拟的圆环，如下图所示，范围为 0-2^32-1；对于每个数据，根据key 计算 hash 值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务器。

<img src=".\images\2502.png" alt="2502" style="zoom:80%;" />

与哈希取余分区相比，一致性哈希分区将增减节点的影响限制在相邻节点。以上图为例，如果在 node1 和 node2之间增加 node5，则只有 node2 中的一部分数据会迁移到 node5；如果去掉 node2，则原 node2 中的数据只会迁移到 node4 中，只有 node4 会受影响。

一致性哈希分区的主要问题在于，当节点数量较少时，增加或删减节点，对单个节点的影响可能很大，造成数据的严重不平衡。以上图为例，如果去掉 node2，node4 中的数据由总数据的 1/4 左右变为 1/2 左右，与其他节点相比负载过高。

### 3.1.3 带虚拟节点的一致性哈希分区

该方案在一致性哈希分区的基础上，引入了虚拟节点的概念。其中虚拟节点称为槽（slot），**槽是介于数据和实际节点之间的虚拟概念**；每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。引入槽以后，数据的映射关系由**数据hash->实际节点**，变成了**数据hash->槽->实际节点**。

在带虚拟节点的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点之间的关系，增加或删除节点对系统的影响很小（系统默认方案）。

仍以上图为例，系统中有4个实际节点，假设为其分配16个槽(0-15)；  槽0-3位于 node1，4-7位于 node2，以此类推。如果此时删除 node2，只需要将槽4-7重新分配即可，例如槽4-5分配给 node1，槽6分配给 node3，槽7分配给 node4；可以看出删除 node2后，数据在其他节点的分布仍然较为均衡。

Redis集群将数据映射到实际节点的过程如下图：

<img src=".\images\2503.png" alt="2503" style="zoom:80%;" />

- Redis 对数据的特征值（key）计算哈希值，使用的算法是 CRC16；
- 根据哈希值，计算数据属于哪个槽；
- 根据槽与节点的映射关系，计算数据属于哪个节点。

## 3.2 节点通信机制

### 3.2.1 两个端口

集群中的每个节点，都提供了两个 TCP 端口：

- 普通端口：用于为客户端提供服务（与单机节点类似 6379），在节点间数据迁移时也会使用。
- 集群端口：用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信；集群端口=普通端口+10000（10000 是固定值，无法改变）

### 3.2.2 通信协议

节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip 协议等。

- 广播：向集群内所有节点发送消息。
  - 优点：集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)；
  - 缺点：每条消息都要发送给所有节点，CPU、带宽等消耗较大。

- Gossip 协议：在节点数量有限的网络中，每个节点都“随机”的与部分节点通信（“随机”：根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。
  - 优点：负载(比广播)低、去中心化、容错性高(因为通信有冗余)等；
  - 缺点：集群的收敛速度慢。

### 3.2.3 消息类型

集群中的节点采用固定频率（每秒10次）的定时任务进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。

节点间发送的消息主要分为5种：meet 消息、ping 消息、pong 消息、fail 消息、publish 消息。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的。

- **MEET 消息**：在节点握手阶段，当节点收到客户端的 `CLUSTER MEET` 命令时，会向新加入的节点发送 MEET 消息，请求新节点加入到当前集群；新节点收到 MEET 消息后会回复一个 PONG 消息。

- **PING 消息**：集群里每个节点每秒钟会选择部分节点发送 PING 消息，接收者收到消息后会回复一个 PONG 消息。PING 消息的内容是自身节点和部分其他节点的状态信息；作用是彼此交换信息，以及检测节点是否在线。

  PING 消息使用 Gossip 协议发送，接收节点的选择兼顾了收敛速度和带宽成本，具体规则如下：

  - 随机找 5 个节点，在其中选择最久没有通信的 1 个节点；
  - 扫描节点列表，选择最近一次收到 PONG 消息时间大于 `cluster_node_timeout/2` 的所有节点，防止这些节点长时间未更新。

- **PONG 消息**：PONG 消息封装了自身状态数据。可以分为两种：1).在接到 MEET/PING 消息后回复的 PONG消息；2).指节点向集群广播 PONG 消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播 PONG 消息。

- **FAIL 消息**：当一个主节点判断另一个主节点进入 FAIL 状态时，会向集群广播这一 FAIL 消息；接收节点会将这一 FAIL 消息保存起来，便于后续的判断。

- **PUBLISH 消息**：节点收到 PUBLISH 命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该 PUBLISH 命令。

## 3.3 数据结构

节点为了存储集群状态而提供的数据结构中，最关键的是 clusterNode 和 clusterState 结构。

### 3.3.1 clusterNode

**保存了一个节点的当前状态**，包括创建时间、节点id、ip和端口号等。clusterNode 分别源码说明如下：

```tex
typedef struct clusterNode {
    //节点创建时间
    mstime_t ctime;
    
    //节点id
    char name[REDIS_CLUSTER_NAMELEN];
    //节点的ip和端口号
    char ip[REDIS_IP_STR_LEN];
    int port;
 
    //节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等
    int flags;
 
    //配置纪元：故障转移时起作用，类似于哨兵的配置纪元
    uint64_t configEpoch;
 
    //槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中
    unsigned char slots[16384/8];
    
    //节点中槽的数量
    int numslots; 
    ……
} clusterNode;
```

除了上述字段，clusterNode 还包含节点连接、主从复制、故障发现和转移需要的信息等。

### 3.3.2 clusterState

clusterState 结构保存了在当前节点视角下，集群所处的状态。主要字段包括：

```tex
typedef struct clusterState {
    //自身节点
    clusterNode *myself;
 
    //配置纪元
    uint64_t currentEpoch;
 
    //集群状态：在线还是下线
    int state;
 
    //集群中至少包含一个槽的节点数量
    int size;
 
    //哈希表，节点名称->clusterNode节点指针
    dict *nodes;
  
    //槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL
    clusterNode *slots[16384];
    ……
} clusterState;
```

除此之外，clusterState 还包括故障转移、槽迁移等需要的信息。

## 3.4 集群命令的实现

以 cluster meet(节点握手)、cluster addslots(槽分配)为例，说明节点是如何利用上述数据结构和通信机制实现集群命令的。

### 3.4.1 cluster meet

假设要向 A 节点发送 `cluster meet` 命令，将 B 节点加入到 A 所在的集群，则 A 节点收到命令后，执行的操作如下：

- A 为 B 创建一个 clusterNode 结构，并将其添加到 clusterState 的 nodes 字典中

- A 向 B 发送MEET消息

- B 收到 MEET 消息后，会为 A 创建一个 clusterNode 结构，并将其添加到 clusterState 的 nodes 字典中

- B 回复 A 一个 PONG 消息

- A 收到 B 的 PONG 消息后，便知道 B 已经成功接收自己的 MEET 消息

- 然后，A 向 B 返回一个 PING 消息

- B 收到 A 的 PING 消息后，便知道 A 已经成功接收自己的 PONG 消息，握手完成

- 接着，A 通过 Gossip 协议将 B 的信息广播给集群内其他节点，其他节点也会与 B 握手；一段时间后，集群收敛，B 成为集群内的一个普通节点

通过上述过程可以发现，集群中两个节点的握手过程与 TCP 类似，都是三次握手：A 向 B 发送 MEET；B 向 A 发送 PONG；A 向 B 发送 PING。

### 3.4.2 cluster addslots

集群中槽的分配信息，存储在 clusterNode 的 slots 数组和 clusterState 的 slots 数组中。二者的区别在于：前者存储的是该节点中分配了哪些槽，后者存储的是集群中所有槽分别分布在哪个节点。

`cluster addslots` 命令接收一个槽或多个槽作为参数，例如：在A节点上执行 `cluster addslots {0..10}` 命令，是将编号为 0-10 的槽分配给 A 节点，具体执行过程如下：

- 遍历输入槽，检查它们是否都没有分配，如果有一个槽已分配，命令执行失败；方法是检查输入槽在clusterState.slots[] 中对应的值是否为 NULL。

- 遍历输入槽，将其分配给节点 A；方法是修改 clusterNode.slots[] 中对应的比特为1，以及clusterState.slots[] 中对应的指针指向 A 节点

- A 节点执行完成后，通过节点通信机制通知其他节点，所有节点都会知道 0-10 的槽分配给了 A 节点。

# 4 Java 客户端访问集群

使用 JedisCluster 访问集群伪代码：

```tex
@Test
public void testJedisCluster() {
    // 创建一个JedisCluster对象，构造参数set类型，集合中每个元素是PostAndPort类型
    Set<HostAndPort> nodes = new HashSet<>();
    nodes.add(new HostAndPort("47.106.125.36", 7001));
    nodes.add(new HostAndPort("47.106.125.36", 7002));
    nodes.add(new HostAndPort("47.106.125.36", 7003));
    nodes.add(new HostAndPort("47.106.125.36", 8001));
    nodes.add(new HostAndPort("47.106.125.36", 8002));
    nodes.add(new HostAndPort("47.106.125.36", 8003));
    JedisCluster cluster = new JedisCluster(nodes);
    // 直接使用cluster对象操作redis，自带连接池，jedisCluster对象可以是单例的
    cluster.set("JedisCluster", "123456");
    System.out.println(cluster.get("JedisCluster"));
    cluster.close();
}
```

代码的基本实现原理如下：

- JedisCluster 初始化时，在内部维护 slot->node 的缓存，方法是连接任一节点，执行 cluster slots 命令；
- edisCluster 为每个节点创建连接池(JedisPool)；
- 当执行命令时，JedisCluster 根据 key->slot->node 选择需要连接的节点，发送命令。如果成功，则命令执行完毕。如果执行失败，则会随机选择其他节点进行重试，并在出现 MOVED 错误时，使用 cluster slots 重新同步 slot->node 的映射关系。

# 5 实践须知

## 5.1 集群伸缩

实践中常常需要对集群进行伸缩，如访问量增大时的扩容操作。Redis集群可以在不影响对外服务的情况下实现伸缩；**伸缩的核心是槽迁移：修改槽与节点的对应关系，实现槽(数据)在节点之间的移动**。

例如：如果槽均匀分布在集群的 3 个节点中，增加一个节点，则需要从 3 个节点中分别拿出一部分槽给新节点，从而实现槽在 4 个节点中的均匀分布。

### 5.1.1 增加节点

增加 7004(主) 和 8004(从) 节点的步骤如下：

- 启动节点

- 节点握手：可以直接使用 `cluster meet` 命令，但在生产环境中建议使用 redis-trib.rb 的 add-node工 具，其原理也是 `cluster meet`，但它会先检查新节点是否已加入其它集群或者存在数据，避免加入到集群后带来混乱。

  ```tex
  redis-trib.rb add-node 47.106.125.36:7004 47.106.125.36 7001
  redis-trib.rb add-node 47.106.125.36:8004 47.106.125.36 7001
  ```

- 迁移槽：推荐使用 redis-trib.rb 的 reshard 工具实现。reshard 自动化程度很高，只需要输入 `redis-trib.rb reshard ip:port`  (ip:port 为集群中的任一节点)，然后按照提示输入以下信息，槽迁移会自动完成：
  - 待迁移的槽数量：16384个槽均分给4个节点，每个节点4096个槽，因此待迁移槽数量为4096;
  - 目标节点id：7004 节点的 id;
  - 源节点的id：70001/7002/7003 节点的 id。
- 指定主从关系。

### 5.1.2 减少节点

下线 7001/8001 节点的步骤如下：

- 迁移槽：使用 reshard 将 7001 节点中的槽均匀迁移到 7002/7003/7004 节点；

- 下线节点：使用 redis-trib.rb del-node 工具；应先下线从节点再下线主节点，因为若主节点先下线，从节点会被指向其他主节点，造成不必要的全量复制。

  ```tex
  redis-trib.rb del-node 47.106.125.36:7002 {节点7001的id}
  redis-trib.rb del-node 47.106.125.36:8002 {节点8002的id}
  ```

### 5.1.3 ASK 错误

集群伸缩的核心是槽迁移。在槽迁移过程中，如果客户端向源节点发送命令，源节点执行流程如下：

<img src=".\images\2504.png" alt="2504" style="zoom:80%;" />

客户端收到 ASK 错误后，从中读取目标节点的地址信息，并向目标节点重新发送请求，就像收到 MOVED 错误时一样。区别在于：

- ASK 错误说明数据正在迁移，不知道何时迁移完成，因此重定向是临时的，SMART 客户端不会刷新 slots 缓存；
- MOVED 错误重定向则是(相对)永久的，SMART 客户端会刷新 slots 缓存。

## 5.2 故障转移

集群故障转移的实现与哨兵思路类似：通过定时任务发送 PING 消息检测其他节点状态，节点下线分为主观下线和客观下线，客观下线后选取从节点进行故障转移。

与哨兵一样，集群只实现了**主节点的故障转移**；从节点故障时只会被下线，不会进行故障转移。因此，使用集群时，应谨慎使用读写分离技术。

### 主节点数量

在故障转移阶段，需要由主节点投票选出哪个从节点成为新的主节点；从节点选举胜出需要的票数为 N/2+1；其中 N 为主节点数量(包括故障主节点)，但故障主节点实际上不能投票。

### 故障转移时间

从主节点故障发生到完成转移，所需要的时间主要消耗在主观下线识别、主观下线传播、选举延迟等几个环节；具体时间与参数 `cluster-node-timeout有` 关，一般来说：

- 故障转移时间(毫秒) ≤ 1.5 * cluster-node-timeout + 1000

- cluster-node-timeout 的默认值为 15000ms(15s)，因此故障转移时间会在 20s 量级。

## 5.3 集群的限制及应对方法

由于集群中的数据分布在不同节点中，导致一些功能受限，例如：

- key 批量操作受限：例如 `mget、mset` 操作，只有当操作的 key 都位于一个槽时，才能进行。针对该问题，一种思路是在客户端记录槽与 key 的信息，每次针对特定槽执行 mget/mset；另外一种思路是使用 Hash Tag。
- keys/flushall 等操作：keys/flushall 操作可以在任一节点执行，但是结果只针对当前节点，例如 keys 操作只返回当前节点的所有键。针对该问题，可以在客户端使用 `cluster nodes` 获取所有节点信息，并对其中的所有主节点执行 `keys/flushall` 操作。

- 事务/Lua脚本：集群支持事务及 Lua 脚本，但前提条件是所涉及的 key 必须在同一个节点。Hash Tag 可以解决该问题。
- 数据库：单机 Redis 节点可以支持16个数据库，集群模式下只支持一个，即 db0。
- 复制结构：只支持一层复制结构，不支持嵌套。

## 5.4 Hash Tag

**Hash Tag 原理**：当一个 key 包含 {} 的时候，不对整个 key 做 hash，而仅对 {} 中的字符串做 hash。

Hash  Tag 可以让不同的 key 拥有相同的 hash 值，从而分配在同一个槽里；这样针对不同 key 的批量操作(mget/mset等)，以及事务、Lua脚本等都可以支持。不过 Hash Tag 可能会带来数据分配不均的问题，可以通过如下方式优化：

- 调整不同节点中槽的数量，使数据分布尽量均匀；
- 避免对热点数据使用 Hash  Tag，导致请求分布不均。

## 5.5 参数优化

### cluster_node_timeout

`cluster_node_timeout` ，默认 15s，影响包括：

- 影响 PING 消息接收节点的选择：值越大对延迟容忍度越高，选择的接收节点越少，可以降低带宽，但会降低收敛速度；应根据带宽情况和应用要求进行调整；
- 影响故障转移的判定和时间：值越大，越不容易误判，完成转移消耗时间越长；应根据网络状况和应用要求进行调整。

### cluster-require-full-coverage

为了保证集群的完整性，只有当16384个槽全部分配完毕时，集群才能上线。

当主节点发生故障而故障转移尚未完成，原主节点中的槽不在任何节点中，此时会集群处于下线状态，无法响应客户端的请求。

`cluster-require-full-coverage` 参数可以改变这一设定：如果设置为 no，则当槽没有完全分配时，集群仍可以上线。参数默认值为 yes，如果应用对可用性要求较高，可以修改为 no，但需要自己保证槽全部分配。

## 5.6 redis-trib.rb

redis-trib.rb 提供了许多实用工具：创建集群、增减节点、槽迁移、检查完整性、数据重新平衡等。在实践中如果能使用 redis-trib.rb 工具则尽量使用，不但方便快捷，还可以大大降低出错概率。




# 参考：
- [redis中文官方网站](http://www.redis.cn/)
- [深入学习Redis（5）：集群](https://www.cnblogs.com/kismetv/p/9853040.html)
- [深入剖析Redis系列(三)-Redis集群模式搭建与原理](https://zhuanlan.zhihu.com/p/44537690)
- [面试中关于Redis的问题看这篇就够了](https://juejin.im/post/6844903592998993928)

