Redis 学习笔记--集群模式
====================
# 1 Redis 集群简介

Redis 集群（Redis Cluster）是 Redis 3.0 开始引入的分布式存储方案。

集群由多个节点(Node)组成，Redis 的数据分布在这些节点中。集群中的节点分为主节点和从节点：主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。

相对于主从和哨兵模式，Redis 集群的优势主要体现在如下两方面：

- 数据分区（数据分片）：将数据分散到多个节点，一方面突破了 Redis 单机内存大小的限制，存储容量大大增加；另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。
- 高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。

## 架构图

Redis Cluster 架构图如下：

<img src=".\images\2501.png" alt="2501" style="zoom:80%;" />



# 2 Redis Cluster 搭建

集群的搭建方式有两种：

- 手动执行 Redis 命令，一步步完成搭建；
- 使用 Ruby 脚本搭建，原理和第一种相同。使用 Ruby 脚本将 Redis 命令进行了打包封装；在实际应用中推荐使用脚本方式，简单快捷不易出错。

## 2.1 Redis Cluster 规划

|      IP       | 端口号 |  角色  |
| :-----------: | :----: | :----: |
| 47.106.125.36 |  7001  | Master |
| 47.106.125.36 |  7002  | Master |
| 47.106.125.36 |  7003  | Master |
| 47.106.125.36 |  8001  | Slave  |
| 47.106.125.36 |  8002  | Slave  |
| 47.106.125.36 |  8003  | Slave  |

## 2.2 执行 Redis 命令搭建集群

集群的搭建可以分为四步：

- 启动节点：将节点以集群模式启动，此时节点是独立的，并没有建立联系；
- 节点握手：让独立的节点连成一个网络；
- 分配槽：将16384个槽分配给主节点；
- 指定主从关系：为从节点指定主节点。

### 1).启动节点

配置每个节点的 `redis.conf` 相关参数，使用 `./redis-server` 命令启动每个 redis 节点：

```tex
cluster-enabled yes
cluster-config-file "node01.conf"
```

- cluster-enabled yes：Redis 实例分为单机模式(standalone)和集群模式(cluster) ，cluster-enabled yes 表启用集群模式(cluster)。
- cluster-config-file：指定**集群配置文件**的位置。每个节点在运行过程中，会维护一份集群配置文件；当集群信息发生变化时（如增减节点），集群内所有节点会将最新信息更新到该配置文件；当节点重启后，会重新读取该配置文件，获取集群信息。

### 2).节点握手

通过节点握手，将独立的节点组成一个网络。

节点握手使用 `cluster meet {ip} {port}` 命令实现。例如：在 47.106.125.36:7001节点上执行 47.106.125.36:8001 ，可以完成 7001节点和 8001 节点的握手。

### 3).分配槽

槽是数据管理和迁移的基本单位，在 Redis 集群中，借助槽实现数据分区（后文详述）。

集群有 16384 个槽，当数据库中的 16384 个槽都分配了节点时，集群处于上线状态（ok）；如果有任意一个槽没有分配节点，则集群处于下线状态（fail）。

`cluster info` 命令可以查看集群状态，分配槽之前状态为 fail。

分配槽使用 cluster addslots 命令，在各主节点执行  cluster addslots 将槽（编号0-16383）全部分配完毕：

```tex
redis-cli -p 6379 cluster addslots {0..5461}
redis-cli -p 6379 cluster addslots {5462..10922}
redis-cli -p 6379 cluster addslots {10923..16383}
```

### 4).指定主从关系

集群中指定主从关系不再使用 slaveof 命令，而是使用 `cluster replicate` 命令，参数使用节点 id。

通过 `cluster nodes` 命令分别获取主节点id，执行下面的命令为每个从节点指定主节点：

```tex
redis-cli -p 6379 cluster replicate be816eba968bc16c884b963d768c945e86ac51ae
redis-cli -p 6379 cluster replicate 788b361563acb175ce8232569347812a12f1fdb4
redis-cli -p 6379 cluster replicate a26f1624a3da3e5197dde267de683d61bb2dcbf1
```

## 2.3 使用 Ruby 脚本搭建集群

### 1).安装 Ruby 环境

以 Ubuntu 为例，如下操作即可安装 Ruby 环境：

```tex
apt-get install ruby #安装ruby环境
gem install redis #gem是ruby的包管理工具，用于安装ruby-redis依赖
```

### 2).启动节点

与第一种方法相同。

### 3).搭建集群

redis-trib.rb 脚本提供了许多命令，其中 create 用于搭建集群，具体操作如下：

```tex
./redis-trib.rb create --replicas 1 47.106.125.36 6379 47.106.125.36 6380 47.106.125.37 6379 47.106.125.37 6380 47.106.125.386379 47.106.125.38 6380
```

--replicas=1表示每个主节点有1个从节点；后面的多个{ip:port}表示节点地址，前面是主节点，后面是从节点。使用redis-trib.rb搭建集群时，要求节点不能包含任何槽和数据。

# 3 集群的基本原理

## 3.1 数据分区方案

数据分区有顺序分区、哈希分区等，其中哈希分区由于其天然的随机性，使用广泛；集群的分区方案便是哈希分区的一种。

**哈希分区的基本思路**：对数据的特征值（如key）进行哈希，然后根据哈希值决定数据落在哪个节点。

常见的哈希分区包括：哈希取余分区、一致性哈希分区、带虚拟节点的一致性哈希分区等。

### 哈希取余分区

哈希取余分区思路：计算 key 的 hash 值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。

该方案最大的问题是，当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。

### 一致性哈希分区

一致性哈希算法将整个哈希值空间组织成一个虚拟的圆环，如下图所示，范围为 0-2^32-1；对于每个数据，根据key 计算 hash 值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务器。

<img src=".\images\2502.png" alt="2502" style="zoom:80%;" />

与哈希取余分区相比，一致性哈希分区将增减节点的影响限制在相邻节点。以上图为例，如果在node1和node2之间增加node5，则只有node2中的一部分数据会迁移到node5；如果去掉node2，则原node2中的数据只会迁移到node4中，只有node4会受影响。

一致性哈希分区的主要问题在于，当节点数量较少时，增加或删减节点，对单个节点的影响可能很大，造成数据的严重不平衡。还是以上图为例，如果去掉node2，node4中的数据由总数据的1/4左右变为1/2左右，与其他节点相比负载过高。

### 带虚拟节点的一致性哈希分区

该方案在一致性哈希分区的基础上，引入了虚拟节点的概念。其中虚拟节点称为槽（slot），槽是介于数据和实际节点之间的虚拟概念；每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。引入槽以后，数据的映射关系由数据hash->实际节点，变成了数据hash->槽->实际节点。

在带虚拟节点的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点之间的关系，增加或删除节点对系统的影响很小（系统默认方案）。

仍以上图为例，系统中有4个实际节点，假设为其分配16个槽(0-15)；  槽0-3位于node1，4-7位于node2，以此类推。如果此时删除node2，只需要将槽4-7重新分配即可，例如槽4-5分配给node1，槽6分配给node3，槽7分配给node4；可以看出删除node2后，数据在其他节点的分布仍然较为均衡。

Redis集群将数据映射到实际节点的过程如下图：

<img src=".\images\2503.png" alt="2503" style="zoom:80%;" />

- Redis 对数据的特征值（key）计算哈希值，使用的算法是CRC16；
- 根据哈希值，计算数据属于哪个槽；
- 根据槽与节点的映射关系，计算数据属于哪个节点。

## 3.2 节点通信机制

### 两个端口

集群中的每个节点，都提供了两个TCP端口：

- 普通端口：用于为客户端提供服务（与单机节点类似 6379），在节点间数据迁移时也会使用。
- 集群端口：用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信；集群端口=普通端口+10000（10000是固定值，无法改变）

### 通信协议

节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip 协议等。

- 广播：向集群内所有节点发送消息。
  - 优点：集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)；
  - 缺点：每条消息都要发送给所有节点，CPU、带宽等消耗较大。

- Gossip 协议：在节点数量有限的网络中，每个节点都“随机”的与部分节点通信（“随机”：根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。
  - 优点：负载(比广播)低、去中心化、容错性高(因为通信有冗余)等；
  - 缺点：集群的收敛速度慢。

### 消息类型

集群中的节点采用固定频率（每秒10次）的定时任务进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。

节点间发送的消息主要分为5种：meet消息、ping消息、pong消息、fail消息、publish消息。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的。

- MEET消息：在节点握手阶段，当节点收到客户端的CLUSTER MEET命令时，会向新加入的节点发送MEET消息，请求新节点加入到当前集群；新节点收到MEET消息后会回复一个PONG消息。
- PING消息：集群里每个节点每秒钟会选择部分节点发送PING消息，接收者收到消息后会回复一个PONG消息。PING消息的内容是自身节点和部分其他节点的状态信息；作用是彼此交换信息，以及检测节点是否在线。PING消息使用Gossip协议发送，接收节点的选择兼顾了收敛速度和带宽成本，具体规则如下：(1)随机找5个节点，在其中选择最久没有通信的1个节点(2)扫描节点列表，选择最近一次收到PONG消息时间大于cluster_node_timeout/2的所有节点，防止这些节点长时间未更新。

- PONG消息：PONG消息封装了自身状态数据。可以分为两种：第一种是在接到MEET/PING消息后回复的PONG消息；第二种是指节点向集群广播PONG消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播PONG消息。

- FAIL消息：当一个主节点判断另一个主节点进入FAIL状态时，会向集群广播这一FAIL消息；接收节点会将这一FAIL消息保存起来，便于后续的判断。

- PUBLISH消息：节点收到PUBLISH命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该PUBLISH命令。

## 3.3 数据结构

节点为了存储集群状态而提供的数据结构中，最关键的是clusterNode和clusterState结构。

### clusterNode

**保存了一个节点的当前状态**，包括创建时间、节点id、ip和端口号等。clusterNode 分别源码说明如下：

```tex
typedef struct clusterNode {
    //节点创建时间
    mstime_t ctime;
    
    //节点id
    char name[REDIS_CLUSTER_NAMELEN];
    //节点的ip和端口号
    char ip[REDIS_IP_STR_LEN];
    int port;
 
    //节点标识：整型，每个bit都代表了不同状态，如节点的主从状态、是否在线、是否在握手等
    int flags;
 
    //配置纪元：故障转移时起作用，类似于哨兵的配置纪元
    uint64_t configEpoch;
 
    //槽在该节点中的分布：占用16384/8个字节，16384个比特；每个比特对应一个槽：比特值为1，则该比特对应的槽在节点中；比特值为0，则该比特对应的槽不在节点中
    unsigned char slots[16384/8];
    
    //节点中槽的数量
    int numslots; 
    ……
} clusterNode;
```

除了上述字段，clusterNode 还包含节点连接、主从复制、故障发现和转移需要的信息等。

### clusterState

clusterState结构保存了在当前节点视角下，集群所处的状态。主要字段包括：

```tex
typedef struct clusterState {
    //自身节点
    clusterNode *myself;
 
    //配置纪元
    uint64_t currentEpoch;
 
    //集群状态：在线还是下线
    int state;
 
    //集群中至少包含一个槽的节点数量
    int size;
 
    //哈希表，节点名称->clusterNode节点指针
    dict *nodes;
  
    //槽分布信息：数组的每个元素都是一个指向clusterNode结构的指针；如果槽还没有分配给任何节点，则为NULL
    clusterNode *slots[16384];
    ……
} clusterState;
```

除此之外，clusterState还包括故障转移、槽迁移等需要的信息。

## 3.4 集群命令的实现

以cluster meet(节点握手)、cluster addslots(槽分配)为例，说明节点是如何利用上述数据结构和通信机制实现集群命令的。

### cluster meet

假设要向A节点发送 cluster meet命令，将B节点加入到A所在的集群，则A节点收到命令后，执行的操作如下：

- A为B创建一个clusterNode结构，并将其添加到clusterState的nodes字典中

- A向B发送MEET消息

- B收到MEET消息后，会为A创建一个clusterNode结构，并将其添加到clusterState的nodes字典中

- B回复A一个PONG消息

- A收到B的PONG消息后，便知道B已经成功接收自己的MEET消息

- 然后，A向B返回一个PING消息

- B收到A的PING消息后，便知道A已经成功接收自己的PONG消息，握手完成

- 之后，A通过Gossip协议将B的信息广播给集群内其他节点，其他节点也会与B握手；一段时间后，集群收敛，B成为集群内的一个普通节点

通过上述过程可以发现，集群中两个节点的握手过程与TCP类似，都是三次握手：A向B发送MEET；B向A发送PONG；A向B发送PING。

### cluster addslots

集群中槽的分配信息，存储在 clusterNode 的 slots 数组和 clusterState 的 slots 数组中。二者的区别在于：前者存储的是该节点中分配了哪些槽，后者存储的是集群中所有槽分别分布在哪个节点。

cluster addslots命令接收一个槽或多个槽作为参数，例如在A节点上执行cluster addslots {0..10}命令，是将编号为0-10的槽分配给A节点，具体执行过程如下：

- 遍历输入槽，检查它们是否都没有分配，如果有一个槽已分配，命令执行失败；方法是检查输入槽在clusterState.slots[]中对应的值是否为NULL。

- 遍历输入槽，将其分配给节点A；方法是修改clusterNode.slots[]中对应的比特为1，以及clusterState.slots[]中对应的指针指向A节点

- A节点执行完成后，通过节点通信机制通知其他节点，所有节点都会知道0-10的槽分配给了A节点

# 4 Java 客户端访问集群

使用 JedisCluster 访问集群伪代码：

```tex
@Test
public void testJedisCluster() {
    // 创建一个JedisCluster对象，构造参数set类型，集合中每个元素是PostAndPort类型
    Set<HostAndPort> nodes = new HashSet<>();
    nodes.add(new HostAndPort("47.106.125.36", 7001));
    nodes.add(new HostAndPort("47.106.125.36", 7002));
    nodes.add(new HostAndPort("47.106.125.36", 7003));
    nodes.add(new HostAndPort("47.106.125.36", 8001));
    nodes.add(new HostAndPort("47.106.125.36", 8002));
    nodes.add(new HostAndPort("47.106.125.36", 8003));
    JedisCluster cluster = new JedisCluster(nodes);
    // 直接使用cluster对象操作redis，自带连接池，jedisCluster对象可以是单例的
    cluster.set("JedisCluster", "123456");
    System.out.println(cluster.get("JedisCluster"));
    cluster.close();
}
```

代码的基本实现原理如下：

- JedisCluster 初始化时，在内部维护 slot->node 的缓存，方法是连接任一节点，执行cluster slots命令；
- edisCluster为每个节点创建连接池(JedisPool)；
- 当执行命令时，JedisCluster根据key->slot->node选择需要连接的节点，发送命令。如果成功，则命令执行完毕。如果执行失败，则会随机选择其他节点进行重试，并在出现MOVED错误时，使用cluster slots重新同步slot->node的映射关系。

# 5 实践须知

## 5.1 集群伸缩

实践中常常需要对集群进行伸缩，如访问量增大时的扩容操作。Redis集群可以在不影响对外服务的情况下实现伸缩；**伸缩的核心是槽迁移：修改槽与节点的对应关系，实现槽(数据)在节点之间的移动**。

例如，如果槽均匀分布在集群的3个节点中，增加一个节点，则需要从3个节点中分别拿出一部分槽给新节点，从而实现槽在4个节点中的均匀分布。








# 参考：
- [redis中文官方网站](http://www.redis.cn/)
- [Redis的文档](http://www.redis.cn/documentation.html)
- [深入学习Redis（5）：集群](https://www.cnblogs.com/kismetv/p/9853040.html)
