Java 虚拟机--编写高效优雅的 java 程序
====================
## 1 面向对象

### 1.1 构造器参数太多怎么办？
如果参数很多，会导致构造方法非常多，拓展性差，代码难编写，且难以看懂。

用 JavaBean 的方式，get、set 方法将导致一行构造方法需要多行代码来实现，并且需要使用额外机制确保一致性和线程安全。

可使用 [建造者模式](https://github.com/IamDingj/design-patterns/blob/master/notes/16.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.md) 来创建对象，代码将更有弹性、易于阅读，而且比 JavaBean 的方式更安全。

一般地，碰到如下场景可以考虑使用建造者模式来优化代码：
- 有 5 个或者 5 个以上的成员变量
- 参数不多，但是以后参数会增加

### 1.2 不需要实例化的类应该构造器私有
一些工具类提供的都是静态方法，这些类不应该提供具体的实例，例如：java.util.Arrays。

好处：防止使用者 new 出多个实例。

### 1.3 不要创建不必要的对象
- 能用基本类型时尽量要用基本类型。比如我们做数字运算，如果定义称了个Long 类型，会涉及到自动装箱。
- 对于程序中共用的参数尽量设置为 static 类型变量。
- 对于耗时性较大的对象比如数据库连接，尽量创建数据库连接池。
- 对于占据内存较大的对象尽量少创建。因为在 eden 区来回倒腾。

### 1.4 避免使用终结方法
- finalze()
  - finalize() 是 Object 的 protected 方法，子类可以覆盖该方法以实现资源清理工作，GC 在回收对象之前调用该方法；
  - finalize() 与 C++ 中的析构函数不是对应的。C++ 中的析构函数调用的时机是确定的（对象离开作用域或 delete 掉），但Java 中的 finalize 的调用具有不确定性。
  
- System.gc()   
  调用 System.gc() 的时候，其实并不会马上进行垃圾回收，甚至不一定会执行垃圾回收。查看 System.gc() 的源码可以看到只有当 justRanFinalization=true 的时候系统才会真正 GC。

### 1.5 使类和成员的可访问性最小化
说白了就是最少知识原则（请移步 [面向对象设计原则](https://github.com/IamDingj/design-patterns/blob/master/notes/02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.md)） 。

### 1.6 使可变性最小化
可变性小更易于设计、实现和使用，而且更不容易出错，更安全。

不可变类的 5 个原则：
- 不要提供任何改变对象状态的方法 setter；
- 保证类不会被扩展；
- 确保所有的域都是 final 的；
- 确保所有的域都是私有的；
- 确保客户端无法访问可变对象的引用。

### 1.7 复合优先于继承
继承是实现代码重用的有力手段，但是使用不当会导致软件变得脆弱。在包的内部使用继承是非常安全的，子类和超类的实现都处在同一个程序员的控制之下。对于专门为了继承而设计、并且具有很好的文档说明的类来说，使用继承也是非常安全的。然而们对于进行跨越包边界的继承，则要非常小心。“继承”在这里特指一个类扩展另一个类。需要我们对父类十分对了解才可继承，只有当子类和超类之间确实存在父子关系时，才可以考虑使用继承。否则都应该用复合，包装类不仅比子类更加健壮，而且功能也更加强大。

### 1.8 接口优于抽象类
java 是单继承（不能继承多个抽象类），但类允许实现多个接口。当业务发生变化时，只需针对该业务场景适当的新增接口即可，抽象类有可能导致不需要变化的类也不得不实现新增的业务方法。

JDK源码中常用的一种设计方法：定义一个接口，声明一个抽象的骨架类实现接口，骨架类类实现通用的方法，而实际的业务类可以同时实现接口又继承骨架类，也可以只实现接口。如 HashSet 实现了 implements Set 接口 但是又extends 类 AbstractSet，而 AbstractSet 本身也实现了 Set 接口。其他如 Map，List 都是这样设计的。


## 2 方法
### 2.1 可变参数要谨慎使用
JDK5 增加了可变参数方法(variable arity method)，可变参数方法接受 0 ~ n 个指定类型的参数。

可变参数机制：先创建一个数组，数组大小为调用位置所传递的参数数量，然后将参数值传递到数组中，最后将数组传递给方法。

使用可变参数的缺点：

- 若所传参数为 null，方法里有对参数的引用（比如 args[0]）时，那么就会在运行时失败（编译时却检测不出错误）；
- 在对性能有要求时，我们要慎重考虑是否使用可变参数。因为可变参数方法的调用会引起数组的内存分配和初始化，从而带来性能损耗；
- 当可变参数的使用发生变动时（如：以前用可变参数方法，现在用普通方法），所有引用参数列表的类的 .class 文件都要重新生成，因为数组的内存分配和初始化是在编译期间完成的；
- 代码可读性差。

Effective Java 建议：假设调用可变参数的方法中，有 95% 调用参数个数小于4，那么就可以将个数小于4的方法，用普通方法定义；剩余的5%，调用可变参数方法。


### 2.2 返回零长度的数组或集合，不要返回 null
方法的结果返回 null，会导致调用方的要单独处理为 null 的情况。返回零长度数组或集合（Collections.EMPTY_LIST），调用方可以统一处理（如使用 foreach）。

### 2.3 优先使用标准的异常
追求代码的重用，同时减少类加载的数目，提高类装载的性能。


## 3 通用程序设计
### 3.1 用枚举代替 int 常量
声明的一个枚举本质就是一个类，每个具体的枚举值就是这个枚举类的实例。

好处有：
- 使用常量容易在写代码时写错；
- 使用常量如果要使用描述时比较麻烦；
- 其他类使用常量时，类编译时会把常量值直接写到字节码中，如果常量值有变化，所有相关的类需要重新编译，否则会不可预料的错误。

### 3.2 将局部变量的作用域最小化
尽量在第一次使用的地方进行声明及初始化。

好处：减小局部变量表的大小，提高性能；同时避免局部变量过早声明导致不正确的使用。

### 3.3 精确计算，避免使用 float 和 double
float 和 double 在 JVM 存储的时候，有部分要做整数位，有部分做小数位，所以存在精度上的问题。可以使用 int、long 以及 BigDecimal 等。

### 3.4 当心字符串连接的性能
存在大量字符串或者大型字符串拼接的时，尽量使用 StringBuilder 和 StringBuffer。

### 3.5 控制方法的大小
参考 [java中方法不要写太长的真正原因](https://blog.csdn.net/enetor1/article/details/83879251) 。

# 参考
- 《Effective Java》
- [finalize()方法详解](https://www.cnblogs.com/qfchen/p/11322134.html) 
- [Java之花样玩枚举](https://sowhat.blog.csdn.net/article/details/100596880) 
- [java中方法不要写太长的真正原因](https://blog.csdn.net/enetor1/article/details/83879251) 
